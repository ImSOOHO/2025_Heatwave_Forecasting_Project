# -*- coding: utf-8 -*-
"""대학원_폭염예측.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M0MEzQh8w4mdQJI4JT658B5AaN-aHDC3

# 기초 세팅
"""

# Commented out IPython magic to ensure Python compatibility.
# 한글 깨짐 방지
# %config InlineBackend.figure_format = "retina"
import warnings
warnings.filterwarnings(action='ignore')
from IPython.display import display
from IPython.display import HTML

!sudo apt-get install -y fonts-nanum
!sudo fc-cache -fv
!rm ~/.cache/matplotlib -rf
import matplotlib.pyplot as plt
plt.rc('font', family='NanumBarunGothic')

!pip install numpy==1.24.3 pmdarima folium geopandas ortools

import os
import sys
import warnings
warnings.filterwarnings("ignore", message=".*force_all_finite.*")
warnings.filterwarnings("ignore", category=FutureWarning)

import pandas as pd
import numpy as np
from datetime import timedelta
import matplotlib.pyplot as plt
import seaborn as sns
import geopandas as gpd
from shapely.geometry import Point
import folium

from pmdarima import auto_arima
from pmdarima.preprocessing import FourierFeaturizer
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error

"""# 데이터 불러오기"""

df = pd.read_csv("/content/drive/MyDrive/통계분석및실습/2014.10.05~2024.10.05 날씨데이터 V2.csv", encoding='cp949')

"""# 전처리 및 EDA

칼럼 괄호 및 단위 제거
"""

df.columns = df.columns.str.replace(r'\(.*?\)', '', regex=True)
df.columns = df.columns.str.replace(' ', '')

"""시도, 시군구 칼럼 추가"""

# 시도 정보 딕셔너리
sido_dict = {
    '속초': '강원도',
    '북춘천': '강원도',
    '철원': '강원도',
    '동두천': '경기도',
    '파주': '경기도',
    '대관령': '강원도',
    '춘천': '강원도',
    '백령도': '인천광역시',
    '북강릉': '강원도',
    '강릉': '강원도',
    '동해': '강원도',
    '서울': '서울특별시',
    '인천': '인천광역시',
    '원주': '강원도',
    '울릉도': '경상북도',
    '수원': '경기도',
    '영월': '강원도',
    '충주': '충청북도',
    '서산': '충청남도',
    '울진': '경상북도',
    '청주': '충청북도',
    '대전': '대전광역시',
    '추풍령': '충청북도',
    '안동': '경상북도',
    '상주': '경상북도',
    '포항': '경상북도',
    '군산': '전라북도',
    '대구': '대구광역시',
    '전주': '전라북도',
    '울산': '울산광역시',
    '창원': '경상남도',
    '광주': '광주광역시',
    '부산': '부산광역시',
    '통영': '경상남도',
    '목포': '전라남도',
    '여수': '전라남도',
    '흑산도': '전라남도',
    '완도': '전라남도',
    '고창': '전라북도',
    '순천': '전라남도',
    '진도(첨찰산)': '전라남도',
    '대구(기)': '대구광역시',
    '홍성': '충청남도',
    '서청주': '충청북도',
    '제주': '제주특별자치도',
    '고산': '제주특별자치도',
    '성산': '제주특별자치도',
    '서귀포': '제주특별자치도',
    '진주': '경상남도',
    '강화': '인천광역시',
    '양평': '경기도',
    '이천': '경기도',
    '인제': '강원도',
    '홍천': '강원도',
    '태백': '강원도',
    '정선군': '강원도',
    '제천': '충청북도',
    '보은': '충청북도',
    '천안': '충청남도',
    '보령': '충청남도',
    '부여': '충청남도',
    '금산': '충청남도',
    '세종': '세종특별자치시',
    '부안': '전라북도',
    '임실': '전라북도',
    '정읍': '전라북도',
    '남원': '전라북도',
    '장수': '전라북도',
    '고창군': '전라북도',
    '영광군': '전라남도',
    '김해시': '경상남도',
    '순창군': '전라북도',
    '북창원': '경상남도',
    '양산시': '경상남도',
    '보성군': '전라남도',
    '강진군': '전라남도',
    '장흥': '전라남도',
    '해남': '전라남도',
    '고흥': '전라남도',
    '의령군': '경상남도',
    '함양군': '경상남도',
    '광양시': '전라남도',
    '진도군': '전라남도',
    '봉화': '경상북도',
    '영주': '경상북도',
    '문경': '경상북도',
    '청송군': '경상북도',
    '영덕': '경상북도',
    '의성': '경상북도',
    '구미': '경상북도',
    '영천': '경상북도',
    '경주시': '경상북도',
    '거창': '경상남도',
    '합천': '경상남도',
    '밀양': '경상남도',
    '산청': '경상남도',
    '거제': '경상남도',
    '남해': '경상남도',
    '북부산': '부산광역시',
}

# 시군구 정보 딕셔너리
sigungu_dict = {
    '속초': '속초시',
    '북춘천': '춘천시',
    '철원': '철원군',
    '동두천': '동두천시',
    '파주': '파주시',
    '대관령': '평창군',
    '춘천': '춘천시',
    '백령도': '옹진군',
    '북강릉': '강릉시',
    '강릉': '강릉시',
    '동해': '동해시',
    '서울': '서울특별시',
    '인천': '인천광역시',
    '원주': '원주시',
    '울릉도': '울릉군',
    '수원': '수원시',
    '영월': '영월군',
    '충주': '충주시',
    '서산': '서산시',
    '울진': '울진군',
    '청주': '청주시',
    '대전': '대전광역시',
    '추풍령': '상주시',
    '안동': '안동시',
    '상주': '상주시',
    '포항': '포항시',
    '군산': '군산시',
    '대구': '대구광역시',
    '전주': '전주시',
    '울산': '울산광역시',
    '창원': '창원시',
    '광주': '광주광역시',
    '부산': '부산광역시',
    '통영': '통영시',
    '목포': '목포시',
    '여수': '여수시',
    '흑산도': '신안군',
    '완도': '완도군',
    '고창': '고창군',
    '순천': '순천시',
    '진도(첨찰산)': '진도군',
    '대구(기)': '대구광역시',
    '홍성': '홍성군',
    '서청주': '청주시',
    '제주': '제주시',
    '고산': '서귀포시',
    '성산': '서귀포시',
    '서귀포': '서귀포시',
    '진주': '진주시',
    '강화': '강화군',
    '양평': '양평군',
    '이천': '이천시',
    '인제': '인제군',
    '홍천': '홍천군',
    '태백': '태백시',
    '정선군': '정선군',
    '제천': '제천시',
    '보은': '보은군',
    '천안': '천안시',
    '보령': '보령시',
    '부여': '부여군',
    '금산': '금산군',
    '세종': '세종특별자치시',
    '부안': '부안군',
    '임실': '임실군',
    '정읍': '정읍시',
    '남원': '남원시',
    '장수': '장수군',
    '고창군': '고창군',
    '영광군': '영광군',
    '김해시': '김해시',
    '순창군': '순창군',
    '북창원': '창원시',
    '양산시': '양산시',
    '보성군': '보성군',
    '강진군': '강진군',
    '장흥': '장흥군',
    '해남': '해남군',
    '고흥': '고흥군',
    '의령군': '의령군',
    '함양군': '함양군',
    '광양시': '광양시',
    '진도군': '진도군',
    '봉화': '봉화군',
    '영주': '영주시',
    '문경': '문경시',
    '청송군': '청송군',
    '영덕': '영덕군',
    '의성': '의성군',
    '구미': '구미시',
    '영천': '영천시',
    '경주시': '경주시',
    '거창': '거창군',
    '합천': '합천군',
    '밀양': '밀양시',
    '산청': '산청군',
    '거제': '거제시',
    '남해': '남해군',
    '북부산': '부산광역시',
}

# 시도와 시군구 칼럼 추가
df['시도'] = df['지점명'].map(sido_dict)
df['시군구'] = df['지점명'].map(sigungu_dict)

"""월 칼럼 생성"""

# 일시 칼럼을 datetime 형식으로 변환
df['일시'] = pd.to_datetime(df['일시'])

# 월 칼럼 추가
df['월'] = df['일시'].dt.month

"""칼럼 순서 변경"""

cols = list(df.columns)
col_to_move = cols.pop(14)
cols.insert(3, col_to_move)
df = df[cols]

cols = list(df.columns)
col_to_move = cols.pop(13)
cols.insert(2, col_to_move)
df = df[cols]

cols = list(df.columns)
col_to_move = cols.pop(14)
cols.insert(3, col_to_move)
df = df[cols]

"""결측치 확인"""

df = df.sort_values(by=['지점명', '일시']).reset_index(drop=True)

# 지점명별 행수
count_per_station = df['지점명'].value_counts()

plt.figure(figsize=(16, 6))
sns.barplot(x=count_per_station.index, y=count_per_station.values, palette="viridis")
plt.xlabel("지점명")
plt.ylabel("행 개수")
plt.title("지점명별 행 개수")
plt.xticks(rotation=90)
plt.show()

"""행의 개수가 9개년 미만인 지역들을 삭제"""

remove_stations = ['고창', '홍성', '북춘천', '세종', '진도(첨찰산)', '북부산', '서청주', '대구(기)']
df = df[~df['지점명'].isin(remove_stations)].reset_index(drop=True)

"""평균기온에 대한 선형보간"""

# 지점명별 선형 보간
df['평균기온'] = df.groupby('지점명')['평균기온'].transform(lambda x: x.interpolate(method='linear'))

"""최고기온 및 최저기온에 대한 선형보간"""

df['최고기온'] = df.groupby('지점명')['최고기온'].transform(lambda x: x.interpolate(method='linear'))
df['최저기온'] = df.groupby('지점명')['최저기온'].transform(lambda x: x.interpolate(method='linear'))

"""평균풍속, 평균상대습도, 평균증기압, 평균지면운도에 대한 선형보간"""

df['평균풍속'] = df.groupby('지점명')['평균풍속'].transform(lambda x: x.interpolate(method='linear'))
df['평균상대습도'] = df.groupby('지점명')['평균상대습도'].transform(lambda x: x.interpolate(method='linear'))
df['평균증기압'] = df.groupby('지점명')['평균증기압'].transform(lambda x: x.interpolate(method='linear'))
df['평균지면온도'] = df.groupby('지점명')['평균지면온도'].transform(lambda x: x.interpolate(method='linear'))

"""습구온도 칼럼 및 체감온도 칼럼 생성"""

# Stull의 습구온도 추정식 함수 정의
def calculate_wet_bulb_temperature(T, RH):
    Tw = (T * np.arctan(0.151977 * np.sqrt(RH + 8.313659)) +
          np.arctan(T + RH) -
          np.arctan(RH - 1.676331) +
          0.00391838 * (RH ** (3/2)) * np.arctan(0.023101 * RH) -
          4.686035)
    return Tw

# 여름철 체감온도 계산 함수 정의
def calculate_feels_like_temperature(Ta, Tw, RH):
    return -0.2442 + 0.55399 * Tw + 0.45535 * Ta - 0.0022 * Tw**2 + 0.00278 * Tw * Ta + 3.0

# 겨울철 체감온도 계산 함수 정의
def calculate_winter_feels_like_temperature(Ta, V):
    return 13.12 + 0.6215 * Ta - 11.37 * (V ** 0.16) + 0.3965 * (V ** 0.16) * Ta

# 습구온도 계산
df['습구온도'] = calculate_wet_bulb_temperature(df['최고기온'], df['평균상대습도'])

# 여름철 체감온도 계산
df.loc[~df['월'].isin([1, 2, 3, 4, 10, 11, 12]), '체감온도'] = \
    calculate_feels_like_temperature(df['최고기온'], df['습구온도'], df['평균상대습도'])

# 겨울철 체감온도 계산
df.loc[df['월'].isin([1, 2, 3, 4, 10, 11, 12]), '체감온도'] = \
    calculate_winter_feels_like_temperature(df['최저기온'], df['평균풍속'])

df['일시'] = pd.to_datetime(df['일시'])
full_dates = pd.date_range(start='2014-10-05', end='2024-10-05')

# 기준 및 보간 대상 컬럼
group_cols = ['지점명', '시도', '시군구']
numeric_cols = [
    '평균기온', '최저기온', '최고기온', '평균풍속',
    '평균상대습도', '평균증기압', '평균지면온도',
    '습구온도', '체감온도'
]

#누락 날짜 행 추가 + 앞뒤 1일 보간
filled_rows = []

for name, group in df.groupby('지점명'):
    group = group.set_index('일시').sort_index()
    missing = full_dates.difference(group.index)
    meta_info = group[[col for col in group.columns if col not in numeric_cols]].iloc[0]

    for date in missing:
        prev_day = date - pd.Timedelta(days=1)
        next_day = date + pd.Timedelta(days=1)

        row = meta_info.copy()
        row['일시'] = date

        for col in numeric_cols:
            prev_val = group[col].get(prev_day, np.nan)
            next_val = group[col].get(next_day, np.nan)

            if pd.notna(prev_val) and pd.notna(next_val):
                row[col] = (prev_val + next_val) / 2
            elif pd.notna(prev_val):
                row[col] = prev_val
            elif pd.notna(next_val):
                row[col] = next_val
            else:
                row[col] = np.nan

        filled_rows.append(row)

filled_df = pd.DataFrame(filled_rows)
final_df = pd.concat([df, filled_df], ignore_index=True)
final_df['일시'] = pd.to_datetime(final_df['일시'])
final_df = final_df.sort_values(by=['지점명', '일시']).reset_index(drop=True)

#남은 결측치 → 앞뒤 평균 보간
nan_rows = final_df[final_df[numeric_cols].isnull().any(axis=1)].copy()

for idx, row in nan_rows.iterrows():
    name = row['지점명']
    date = row['일시']

    before_1 = final_df[(final_df['지점명'] == name) & (final_df['일시'] == date - timedelta(days=1))]
    after_1  = final_df[(final_df['지점명'] == name) & (final_df['일시'] == date + timedelta(days=1))]
    before_2 = final_df[(final_df['지점명'] == name) & (final_df['일시'] == date - timedelta(days=2))]
    after_2  = final_df[(final_df['지점명'] == name) & (final_df['일시'] == date + timedelta(days=2))]

    for col in numeric_cols:
        if pd.isna(final_df.at[idx, col]):
            if not before_1.empty and not after_1.empty:
                final_df.at[idx, col] = (before_1[col].values[0] + after_1[col].values[0]) / 2
            elif not before_2.empty and not after_2.empty:
                final_df.at[idx, col] = (before_2[col].values[0] + after_2[col].values[0]) / 2

#연속 결측 블록 보간
def interpolate_block(final_df, name, col):
    target = final_df[final_df['지점명'] == name][['일시', col]].set_index('일시').sort_index()
    isna = target[col].isna()

    block_starts = (isna & ~isna.shift(1).fillna(False))
    block_ends = (isna & ~isna.shift(-1).fillna(False))
    block_ranges = list(zip(target.index[block_starts], target.index[block_ends]))

    for start, end in block_ranges:
        before = start - pd.Timedelta(days=1)
        after = end + pd.Timedelta(days=1)

        before_val = target[col].get(before, np.nan)
        after_val = target[col].get(after, np.nan)

        if pd.notna(before_val) and pd.notna(after_val):
            fill_val = (before_val + after_val) / 2
            final_df.loc[
                (final_df['지점명'] == name) &
                (final_df['일시'] >= start) &
                (final_df['일시'] <= end),
                col
            ] = fill_val

# 전체 적용
for col in numeric_cols:
    for name in final_df['지점명'].unique():
        interpolate_block(final_df, name, col)

"""폭염여부 칼럼"""

df['폭염여부'] = np.where(df['체감온도'] >= 33, 1, 0)

subset_df = df.iloc[:, 6:]

# 상관관계 행렬 계산
correlation_matrix = subset_df.corr()
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, fmt=".2f", cmap='coolwarm', square=True)
plt.title('Correlation Heatmap')
plt.show()

# 시도별 개수 계산
sido_counts = df['시도'].value_counts()
plt.figure(figsize=(12, 6))
sido_counts.plot(kind='bar', color='skyblue')
plt.title('시도별 행의 개수')
plt.xlabel('시도')
plt.ylabel('행의 개수')
plt.xticks(rotation=45)
plt.grid(axis='y')
plt.show()

# 시도별 고유 시군구 개수 계산
sido_sigungu_counts = df.groupby('시도')['시군구'].nunique()

plt.figure(figsize=(12, 6))
sido_sigungu_counts.plot(kind='bar', color='lightcoral')
plt.title('시도별 고유 시군구 개수')
plt.xlabel('시도')
plt.ylabel('고유 시군구 개수')
plt.xticks(rotation=45)
plt.grid(axis='y')
plt.show()

# 평균 폭염여부 수 시각화
average_heatwave = df.groupby('지점명')['폭염여부'].mean().reset_index())
average_heatwave.columns = ['지점명', '평균폭염여부']

plt.figure(figsize=(14, 7))
plt.bar(average_heatwave['지점명'], average_heatwave['평균폭염여부'], color='skyblue')
plt.title('지점명별 평균 폭염여부')
plt.xlabel('지점명')
plt.ylabel('평균 폭염여부')
plt.xticks(rotation=90)
plt.grid(axis='y')
plt.tight_layout()
plt.show()

# 상위 30곳 시각화
top_30_heatwave = average_heatwave.sort_values(by='평균폭염여부', ascending=False).head(30)

plt.figure(figsize=(14, 7))
plt.bar(top_30_heatwave['지점명'], top_30_heatwave['평균폭염여부'], color='skyblue')
plt.title('상위 30곳 지점명별 평균 폭염여부')
plt.xlabel('지점명')
plt.ylabel('평균 폭염여부')
plt.xticks(rotation=45)
plt.grid(axis='y')
plt.tight_layout()
plt.show()

# 지점명별 폭염여부 계산 및 상위 30곳 추출
heatwave_count = df[df['폭염여부'] == 1].groupby('지점명')['폭염여부'].count().reset_index()
heatwave_count.columns = ['지점명', '폭염여부_1_개수']
top_30_heatwave_count = heatwave_count.sort_values(by='폭염여부_1_개수', ascending=False).head(30)

plt.figure(figsize=(14, 7))
plt.bar(top_30_heatwave_count['지점명'], top_30_heatwave_count['폭염여부_1_개수'], color='salmon')
plt.title('상위 30곳 지점명별 폭염여부가 1인 행 개수')
plt.xlabel('지점명')
plt.ylabel('폭염여부가 1인 행 개수')
plt.xticks(rotation=45)
plt.grid(axis='y')
plt.tight_layout()
plt.show()

"""평균폭염발생횟수가 많은 상위 10개 지역에 대한 시계열 분석 진행"""

average_heatwave.sort_values(by='평균폭염여부', ascending=False).head(10)

df.to_csv('폭염데이터_전처리완료_대학원.csv', encoding = 'utf-8-sig')

"""# ARIMA, ARIMA + Fourier 급수"""

final_df = pd.read_csv(
    '/content/drive/MyDrive/포트폴리오 프로젝트/통계분석및실습/폭염데이터_전처리완료_대학원.csv',
    encoding='utf-8-sig',
    index_col = 0
)

stations = ['의성','양산시','의령군','광주','함양군','경주시','밀양','북창원','합천','대구']
df_s = final_df[final_df['지점명'].isin(stations)].copy()
df_s['일시'] = pd.to_datetime(df_s['일시'])

final_df

# ARIMA
horizon = 365  # 1년치 예측 기간

for station in stations:
    df_ui = df_s[df_s['지점명'] == station].copy()
    df_ui.set_index('일시', inplace=True)
    df_ui = df_ui.reindex(pd.date_range('2014-10-05','2024-10-05',freq='D'))
    y = df_ui['체감온도'].interpolate(method='linear')

    model_ar = auto_arima(
        y,
        seasonal=False,
        stepwise=True,
        suppress_warnings=True,
        max_p=3, max_q=3, max_d=1, max_order=5
    )
    fc95_ar, ci95_ar = model_ar.predict(n_periods=horizon, return_conf_int=True, alpha=0.05)
    fc99_ar, ci99_ar = model_ar.predict(n_periods=horizon, return_conf_int=True, alpha=0.01)

    idx_fc = pd.date_range(start=y.index[-1] + timedelta(days=1), periods=horizon, freq='D')
    s95_ar = pd.Series(fc95_ar, index=idx_fc)

    plt.figure(figsize=(12,6))
    plt.plot(y.index, y, color='blue', label='실제 체감온도')
    plt.fill_between(idx_fc, ci95_ar[:,0], ci95_ar[:,1],
                     color='skyblue', alpha=0.3, label='95% 신뢰 구간')
    plt.fill_between(idx_fc, ci99_ar[:,0], ci99_ar[:,1],
                     color='lightgreen', alpha=0.3, label='99% 신뢰 구간')
    plt.plot(s95_ar.index, s95_ar, color='orange', label='예측 체감온도 (95%)')
    above_ar = s95_ar[s95_ar >= 33]
    plt.scatter(above_ar.index, above_ar, color='red', label='예측 33도 이상', zorder=5)
    plt.axhline(33, color='gray', linestyle='--', label='33도 기준선')
    plt.title(f'{station} 체감온도 예측 (ARIMA)')
    plt.xlabel('날짜')
    plt.ylabel('체감온도 (°C)')
    plt.legend()
    plt.grid()
    plt.tight_layout()
    plt.show()

#ARIMA + Fourier급수 적용 -> SARIMA 대안
horizon = 365
fourier = FourierFeaturizer(m=365, k=3)

for station in stations:
    df_ui = df_s[df_s['지점명'] == station].copy()
    df_ui.set_index('일시', inplace=True)
    idx = pd.date_range('2014-10-05', '2024-10-05', freq='D')
    df_ui = df_ui.reindex(idx)
    y = df_ui['체감온도'].interpolate()

    df_dummy = pd.DataFrame({'dummy': 0}, index=y.index)
    exog = fourier.fit_transform(df_dummy)

    model = auto_arima(
        y,
        exogenous=exog,
        seasonal=False,
        stepwise=True,
        suppress_warnings=True,
        max_p=3, max_q=3, max_d=1, max_order=5,
        n_jobs=-1
    )

    future_idx = pd.date_range(start=y.index[-1] + timedelta(days=1), periods=horizon, freq='D')
    df_dummy_fut = pd.DataFrame({'dummy': 0}, index=future_idx)
    exog_fut = fourier.transform(df_dummy_fut)

    fc95, ci95 = model.predict(n_periods=horizon, exogenous=exog_fut, return_conf_int=True, alpha=0.05)
    fc99, ci99 = model.predict(n_periods=horizon, exogenous=exog_fut, return_conf_int=True, alpha=0.01)
    idx_fc = future_idx
    s95 = pd.Series(fc95, index=idx_fc)

    plt.figure(figsize=(12,6))
    plt.plot(y.index, y, label='실제 체감온도', color='blue')
    plt.fill_between(idx_fc, ci95[:,0], ci95[:,1], color='skyblue', alpha=0.3, label='95% 신뢰 구간')
    plt.fill_between(idx_fc, ci99[:,0], ci99[:,1], color='lightgreen', alpha=0.3, label='99% 신뢰 구간')
    plt.plot(s95.index, s95, color='orange', label='예측 체감온도 (95%)')
    above = s95[s95 >= 33]
    plt.scatter(above.index, above, color='red', label='예측 33도 이상', zorder=5)
    plt.axhline(33, color='gray', linestyle='--', label='33도 기준선')
    plt.title(f'{station} 체감온도 예측 (ARIMA + Fourier)')
    plt.xlabel('날짜')
    plt.ylabel('체감온도 (°C)')
    plt.legend()
    plt.grid()
    plt.tight_layout()
    plt.show()

"""# LSTM"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install --upgrade --force-reinstall numpy==1.24.3

# Commented out IPython magic to ensure Python compatibility.
# %pip install --upgrade --force-reinstall tensorflow

import os, sys, warnings
warnings.filterwarnings("ignore", message=".*force_all_finite.*")
warnings.filterwarnings("ignore", category=FutureWarning)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import geopandas as gpd
import folium

from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Reshape
from tensorflow.keras.callbacks import EarlyStopping
from tensorflow.keras import backend as K

final_df = pd.read_csv('/content/drive/MyDrive/포트폴리오 프로젝트/통계분석및실습/폭염데이터_전처리완료_대학원.csv', encoding = 'utf-8-sig',index_col=0)

def smape(y_true, y_pred):
    return 100 * np.mean(2 * np.abs(y_pred - y_true) / (np.abs(y_true) + np.abs(y_pred) + 1e-8))

def print_scores(name, y, yhat):
    mse_  = mean_squared_error(y, yhat)
    rmse_ = np.sqrt(mse_)
    mae_  = mean_absolute_error(y, yhat)
    smape_= smape(y, yhat)
    print(f"{name:15s} MSE={mse_:.2f}, RMSE={rmse_:.2f}, MAE={mae_:.2f}, SMAPE={smape_:.2f}%")

# 데이터
df = final_df.copy()
df['일시'] = pd.to_datetime(df['일시'], errors='coerce')
df = df[(df['일시'] >= '2014-10-05') & (df['일시'] <= '2024-10-05')].sort_values('일시')

# 10개 지점
stations = ['의성','양산시','의령군','광주','함양군','경주시','밀양','북창원','합천','대구']
weather_cols = ['평균기온','평균풍속','평균증기압','평균상대습도','체감온도']
exog_cols    = ['month_sin','month_cos','time_idx','time_idx2','season_sin','season_cos']
WINDOW  = 90    # 3개월
HORIZON = 365   # 1년

# 스케일러 및 시퀀스 함수 정의
scaler_w = MinMaxScaler()
scaler_e = MinMaxScaler()

def make_multistep_seq(X, Y, window=WINDOW, horizon=HORIZON):
    xs, ys = [], []
    for i in range(len(X) - window - horizon + 1):
        xs.append(X[i:i+window])
        ys.append(Y[i+window:i+window+horizon])
    return np.array(xs), np.array(ys)

def make_onestep_seq(X, Y, window=WINDOW):
    xs, ys = [], []
    for i in range(len(X) - window):
        xs.append(X[i:i+window])
        ys.append(Y[i+window])
    return np.array(xs), np.array(ys)

#지점별 반복 수행

for station in stations:
    # 지점별 데이터 추출
    df_kj = df[df['지점명'] == station].reset_index(drop=True)

    # 외생 변수 생성
    df_kj['month']      = df_kj['일시'].dt.month
    df_kj['month_sin']  = np.sin(2*np.pi*df_kj['month']/12)
    df_kj['month_cos']  = np.cos(2*np.pi*df_kj['month']/12)
    df_kj['time_idx']   = np.arange(len(df_kj))
    df_kj['time_idx2']  = df_kj['time_idx']**2
    df_kj['season']     = ((df_kj['month']%12 + 3)//3)
    df_kj['season_sin'] = np.sin(2*np.pi*df_kj['season']/4)
    df_kj['season_cos'] = np.cos(2*np.pi*df_kj['season']/4)

    # 컬럼 정의 및 스케일링
    weather_s = scaler_w.fit_transform(df_kj[weather_cols].values)
    exog_s    = scaler_e.fit_transform(df_kj[exog_cols].values)

    # 입력 행렬 결합
    X_all = np.hstack([weather_s, exog_s])

    # 시퀀스 생성
    X_seq, Y_seq = make_multistep_seq(X_all, weather_s)
    X_os, Y_os   = make_onestep_seq(X_all, weather_s)

    # 학습/검증 분리
    split_ms = int(len(X_seq) * 0.8)
    X_tr_ms, Y_tr_ms = X_seq[:split_ms], Y_seq[:split_ms]
    X_va_ms, Y_va_ms = X_seq[split_ms:], Y_seq[split_ms:]
    split_os = int(len(X_os) * 0.8)
    X_tr_os, Y_tr_os = X_os[:split_os], Y_os[:split_os]
    X_va_os, Y_va_os = X_os[split_os:], Y_os[split_os:]

    # 모델 정의 및 학습
    K.clear_session()
    model_ms = Sequential([
        LSTM(80, return_sequences=True, input_shape=(WINDOW, X_tr_ms.shape[2])),
        LSTM(80),
        Dense(HORIZON * weather_s.shape[1]),
        Reshape((HORIZON, weather_s.shape[1]))
    ])
    model_ms.compile('adam', loss='mse')
    model_os = Sequential([
        LSTM(80, return_sequences=True, input_shape=(WINDOW, X_tr_os.shape[2])),
        LSTM(80),
        Dense(weather_s.shape[1])
    ])
    model_os.compile('adam', loss='mse')
    es = EarlyStopping(monitor='val_loss', patience=8, restore_best_weights=True)
    model_ms.fit(X_tr_ms, Y_tr_ms, validation_data=(X_va_ms, Y_va_ms),
                 epochs=100, batch_size=32, callbacks=[es], verbose=1)
    model_os.fit(X_tr_os, Y_tr_os, validation_data=(X_va_os, Y_va_os),
                 epochs=100, batch_size=32, callbacks=[es], verbose=1)

    # 성능 비교
    pred_ms = model_ms.predict(X_va_ms)[:,0,:]
    true_ms = Y_va_ms[:,0,:]
    pred_ms_inv = scaler_w.inverse_transform(pred_ms)
    true_ms_inv = scaler_w.inverse_transform(true_ms)
    pred_ms_feels = pred_ms_inv[:,4]
    true_ms_feels = true_ms_inv[:,4]

    pred_os = model_os.predict(X_va_os)
    pred_os_inv = scaler_w.inverse_transform(pred_os)
    pred_os_feels = pred_os_inv[:,4]
    true_os_feels = scaler_w.inverse_transform(Y_va_os)[:,4]

    print(f"\n▶ {station} In-sample 성능 비교")
    print_scores("One-step 모델", true_os_feels, pred_os_feels)
    print_scores("Multi-step(1st)", true_ms_feels, pred_ms_feels)

    # 1년 예측
    feels_ms = scaler_w.inverse_transform(model_ms.predict(X_all[-WINDOW:].reshape(1,WINDOW,-1))[0])[:,4]

    last_seq_os = X_all[-WINDOW:].reshape(1,WINDOW,-1)
    feels_os = []
    for d in range(1, HORIZON+1):
        p = model_os.predict(last_seq_os)[0]
        feels_os.append(p[4])
        tomorrow = df_kj['일시'].iloc[-1] + pd.Timedelta(days=d)
        t_idx   = df_kj['time_idx'].iloc[-1] + d
        t_idx2  = t_idx**2
        m       = tomorrow.month
        seas    = ((m%12+3)//3)
        ex      = [np.sin(2*np.pi*m/12), np.cos(2*np.pi*m/12),
                   t_idx, t_idx2, np.sin(2*np.pi*seas/4), np.cos(2*np.pi*seas/4)]
        ex_s_   = scaler_e.transform([ex])[0]
        last_seq_os = np.concatenate([last_seq_os[:,1:,:],
                                      np.concatenate([p, ex_s_]).reshape(1,1,-1)],
                                     axis=1)
    feels_os = scaler_w.inverse_transform(
        np.hstack([np.zeros((HORIZON,4)), np.array(feels_os).reshape(-1,1)])
    )[:,4]

    heat_ms = (feels_ms >= 33).sum()
    heat_os = (feels_os >= 33).sum()
    print(f"▶ {station} 미래 1년 폭염일수: Multi-step={heat_ms}일, One-step={heat_os}일")

    # 시각화
    base = df_kj['일시'].iloc[-1]
    dates_fut = pd.date_range(start=base + pd.Timedelta(days=1), periods=HORIZON)
    plt.figure(figsize=(14,6))
    plt.plot(df_kj['일시'], df_kj['체감온도'], color='tab:blue', label='실제 체감온도')
    val_dates = df_kj['일시'].iloc[WINDOW+split_os : WINDOW+split_os+len(pred_os_feels)]
    plt.plot(val_dates, pred_os_feels, color='tab:green', alpha=0.7, label='One-step 검증')
    plt.plot(dates_fut, feels_ms, '--', color='tab:orange', label='Multi-step 예측')
    plt.plot(dates_fut, feels_os, '-.', color='tab:red', label='One-step 반복 예측')
    plt.scatter(dates_fut[feels_ms>=33], feels_ms[feels_ms>=33], c='red',   s=20, label='MS 폭염일(≥33°C)')
    plt.scatter(dates_fut[feels_os>=33], feels_os[feels_os>=33], c='magenta', s=20, label='OS 폭염일(≥33°C)')
    plt.axhline(33, color='black', linestyle=':', label='33°C 기준선')
    plt.legend(loc='upper left')
    plt.title(f"{station} 지점 체감온도 예측 종합")
    plt.xlabel("날짜"); plt.ylabel("체감온도 (°C)")
    plt.grid(True); plt.tight_layout(); plt.show()
