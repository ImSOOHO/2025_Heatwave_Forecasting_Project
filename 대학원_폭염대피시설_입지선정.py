# -*- coding: utf-8 -*-
"""대학원_폭염대피시설_입지선정.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FoCjH9H9WkR1BxZdbB5q4RXBtGuS2F-1

# 필요 라이브러리
"""

from google.colab import drive
drive.mount('/content/drive')

!sudo apt-get install -y fonts-nanum
!sudo fc-cache -fv
!rm ~/.cache/matplotlib -rf
import matplotlib.pyplot as plt
plt.rc('font', family='NanumBarunGothic')

"""# 전처리"""

import pandas as pd

df_su = pd.read_csv('/content/drive/MyDrive/통계분석및실습/수요지.csv', encoding='utf-8-sig')
df_hu = pd.read_csv('/content/drive/MyDrive/통계분석및실습/후보지.csv', encoding='utf-8-sig')

df_su.head()

df_hu.head()

df_su = df_su.iloc[:,:-5]

df_su = df_su.drop('지상층수',axis=1)

from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler()
df_hu['의료시설지수'] = scaler.fit_transform(df_hu[['주변의료시설수(반경1km)']])

df_hu['근린생활지수'] = df_hu['주변제1종근린생활시설수(반경0.5km)'] + df_hu['주변제2종근린생활시설수(반경0.5km)'] + df_hu['노유자시설수(반경0.5km)'] + df_hu['근린생활시설수(반경0.5km)']
df_hu['근린생활지수'] = scaler.fit_transform(df_hu[['근린생활지수']])

df_hu['입지선정계수'] = df_hu['의료시설지수'] + df_hu['근린생활지수']
df_hu

df_su

len(df_hu[df_hu['지상층수']>=2])

df_hu[df_hu['지상층수']>=2]['지상층수'].mean()

df_hu['지상층수'].mean()

df_hu['지상층수'].value_counts(normalize=True)

df_hu = df_hu[df_hu['지상층수']>=2]

len(df_hu)

"""# 입지선정"""

# 공통 함수 정의


import folium
import numpy as np
from scipy.spatial import cKDTree
from ortools.linear_solver import pywraplp
import matplotlib.pyplot as plt

def build_ckdtree_coverage(demand_coords, candidate_coords, radius_km):
    """
    cKDTree를 이용해 각 후보지 j가 커버하는 수요지 인덱스 집합을 계산.
    """
    dem = np.asarray(demand_coords, float)
    cand = np.asarray(candidate_coords, float)
    earth_r = 6371.0
    rad = radius_km / earth_r
    tree = cKDTree(np.radians(dem))
    cov = {}
    for j, pt in enumerate(np.radians(cand)):
        cov[j] = set(tree.query_ball_point(pt, rad))
    return cov

def gaas_contribution(demand_df, candidate_df, radius_km, max_sites):
    """
    GAAS (기여도 기반)으로 max_sites개 후보지 선택.
    반환: selected_indices, coverage_dict, coverage_ratios
    """
    dem = demand_df[['위도','경도']].to_numpy()
    cand = candidate_df[['위도','경도']].to_numpy()
    cov_dict = build_ckdtree_coverage(dem, cand, radius_km)
    uncovered = set(range(len(dem)))
    selected, total_cov, ratios = [], set(), []
    while len(selected) < max_sites and uncovered:
        best_i, best_cov = None, set()
        for i in range(len(cand)):
            if i in selected: continue
            cov = cov_dict[i] & uncovered
            if len(cov) > len(best_cov):
                best_i, best_cov = i, cov
        if best_i is None:
            break
        selected.append(best_i)
        total_cov |= best_cov
        uncovered -= best_cov
        ratios.append(len(total_cov) / len(dem) * 100)
    return selected, cov_dict, ratios

def gaas_weighted(demand_df, candidate_df, radius_km, max_sites, weight_col):
    """
    GAAS (입지선정계수 기반)으로 max_sites개 후보지 선택.
    반환: selected_indices, coverage_dict, coverage_ratios
    """
    dem = demand_df[['위도','경도']].to_numpy()
    cand = candidate_df[['위도','경도']].to_numpy()
    cov_dict = build_ckdtree_coverage(dem, cand, radius_km)
    uncovered = set(range(len(dem)))
    selected, total_cov, ratios = [], set(), []
    while len(selected) < max_sites and uncovered:
        best_i, best_score, best_cov = None, -np.inf, set()
        for i in range(len(cand)):
            if i in selected: continue
            cov = cov_dict[i] & uncovered
            score = len(cov) * candidate_df.iloc[i][weight_col]
            if score > best_score:
                best_i, best_score, best_cov = i, score, cov
        if best_i is None:
            break
        selected.append(best_i)
        total_cov |= best_cov
        uncovered -= best_cov
        ratios.append(len(total_cov) / len(dem) * 100)
    return selected, cov_dict, ratios

def mclp(demand_df, candidate_df, candidate_indices, radius_km, max_final):
    """
    MCLP 모델 실행.
    - candidate_indices: 후보지 DataFrame의 인덱스 리스트
    - 반환: 최종 선택 인덱스 리스트, (coverage_dict는 GAAS 단계에서 사용)
    """
    dem = demand_df[['위도','경도']].to_numpy()
    cand = candidate_df[['위도','경도']].to_numpy()
    # 모든 후보지에 대해 커버리지 계산
    cov_dict = build_ckdtree_coverage(dem, cand, radius_km)

    solver = pywraplp.Solver.CreateSolver('SCIP')
    # BoolVar 정의
    x = {j: solver.BoolVar(f"x[{j}]") for j in candidate_indices}
    y = {i: solver.BoolVar(f"y[{i}]") for i in range(len(dem))}
    # 제약: demand i 는 i를 커버하는 x[j]가 있으면 y[i] ≤ Σ x[j]
    for i in range(len(dem)):
        solver.Add(y[i] <= solver.Sum(x[j] for j in candidate_indices if i in cov_dict[j]))
    # 시설 개수 제약
    solver.Add(solver.Sum(x[j] for j in candidate_indices) <= max_final)
    # 목적: Σ y[i] 최대화
    obj = solver.Objective()
    for i in range(len(dem)):
        obj.SetCoefficient(y[i], 1)
    obj.SetMaximization()
    solver.Solve()
    # 최종 선택 인덱스 반환
    return [j for j in candidate_indices if x[j].solution_value() > 0.5]

def plot_coverage_curve(cov_dict, sel, total, title):
    """
    Detailed coverage curve:
     - 10×6, solid line + circle markers
     - annotated percent labels
     - dashed grid alpha=0.7
     - bold title, labeled axes
    """
    covered = set()
    ratios = []
    for idx in sel:
        covered |= cov_dict[idx]
        ratios.append(len(covered) / total * 100)
    x = range(1, len(ratios) + 1)

    plt.figure(figsize=(10,6))
    plt.plot(x, ratios, marker='o', linestyle='-', linewidth=2)
    for xi, yi in zip(x, ratios):
        plt.text(xi, yi, f"{yi:.1f}%", ha='center', va='bottom')
    plt.title(title, fontsize=16, fontweight='bold')
    plt.xlabel("Number of Selected Sites", fontsize=12)
    plt.ylabel("Coverage Ratio (%)", fontsize=12)
    plt.xticks(x)
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.tight_layout()
    plt.show()

def plot_sites_map(final_df, demand_df, cov_dict, radius_km, title):
    """
    Folium map of demand (blue points) and final sites (red markers + green circles).
    """
    m = folium.Map(location=[demand_df['위도'].mean(), demand_df['경도'].mean()],
                   zoom_start=12)
    for _, r in demand_df.iterrows():
        folium.CircleMarker(
            [r['위도'], r['경도']],
            radius=2, color='blue', fill=True, fill_opacity=0.3
        ).add_to(m)
    for _, r in final_df.iterrows():
        folium.Marker(
            [r['위도'], r['경도']],
            icon=folium.Icon(color='red')
        ).add_to(m)
        folium.Circle(
            [r['위도'], r['경도']],
            radius=radius_km*1000,
            color='green', fill=True, fill_opacity=0.1
        ).add_to(m)
    return m

# GAAS(기여도 기반) → MCLP

R = 0.5
GAAS_K, MCLP_K = 20, 10

# 1) GAAS(기여도)로 20개 후보지 선별
sel20, cov20_orig, _ = gaas_contribution(df_su, df_hu, R, GAAS_K)

# 2) 그 후보지들로 DataFrame 재생성
c20 = df_hu.iloc[sel20].reset_index(drop=True)

# 2-1) c20 기준으로 새로운 coverage_dict 생성
cov20_c20 = build_ckdtree_coverage(
    df_su[['위도','경도']].to_numpy(),
    c20[['위도','경도']].to_numpy(),
    R
)

# 2-2) MCLP 실행 (최종 10개)
sel_m = mclp(df_su, c20, list(range(len(c20))), R, MCLP_K)

# 3) 최종 10개 DataFrame
final_c = c20.iloc[sel_m]

# 4) 커버리지 곡선 시각화
plot_coverage_curve(cov20_c20, sel_m, len(df_su),
                    "MCLP after GAAS(contrib)")

# 5) 최종 사이트 지도에 표시
m = plot_sites_map(final_c, df_su, cov20_c20, R,
                   "GAAS+MCLP (기여도)")
m

# GAAS(입지선정계수 기반) → MCLP
R = 0.5
GAAS_K, MCLP_K = 20, 10

# 1) 원본 후보지 DataFrame 인덱스 재설정
df_hu2 = df_hu.reset_index(drop=True)

# 2) GAAS (입지선정계수 기반) 로 20개 후보지 선택
sel20_w, cov20_w_orig, _ = gaas_weighted(df_su, df_hu2, R, GAAS_K, '입지선정계수')

# 3) 선택된 20개 후보지만으로 DataFrame 재생성
c20_w = df_hu2.iloc[sel20_w].reset_index(drop=True)

# 4) c20_w 기준으로 새로운 커버리지 사전 생성
cov20_c20w = build_ckdtree_coverage(
    df_su[['위도','경도']].to_numpy(),
    c20_w[['위도','경도']].to_numpy(),
    R
)

# 5) MCLP 실행
sel_m_w = mclp(df_su, c20_w, list(range(len(c20_w))), R, MCLP_K)

# 6) 최종 10개 후보지 DataFrame
final_w = c20_w.iloc[sel_m_w]

# 7) 커버리지 곡선 시각화
plot_coverage_curve(cov20_c20w, sel_m_w, len(df_su),
                    "MCLP after GAAS(weighted)")

# 8) 최종 사이트 지도에 표시
m = plot_sites_map(final_w, df_su, cov20_c20w, R,
                   "GAAS+MCLP (Weighted)")
m









